// Generated by CoffeeScript 1.6.2
(function() {
  var CommonTool, RoadTool, SharpTurnTool, StraightRoadTool, Tool, colorSpeed, root,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  root = this;

  colorSpeed = {
    15: 0,
    30: 0.05,
    55: 0.10,
    90: 0.15,
    135: 0.20,
    195: 0.25,
    250: 0.30,
    335: 0.35,
    435: 0.40,
    560: 0.45,
    755: 0.50
  };

  Tool = (function() {
    function Tool() {
      console.log("setting tool", this);
      tools.current = this;
    }

    return Tool;

  })();

  CommonTool = (function(_super) {
    __extends(CommonTool, _super);

    function CommonTool() {
      CommonTool.__super__.constructor.call(this);
      layers.tool.clear();
    }

    CommonTool.prototype.over = function(ent, e) {
      var dist, handle, selected, shortest, _i, _len, _ref;

      if (ent instanceof ents.Node) {
        shortest = 9007199254740992;
        selected = null;
        _ref = ent.handels;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          handle = _ref[_i];
          dist = P(e).distance(handle.pos);
          if (dist < shortest) {
            selected = handle;
            shortest = dist;
          }
        }
        return new RoadTool(selected);
      }
    };

    return CommonTool;

  })(Tool);

  RoadTool = (function(_super) {
    __extends(RoadTool, _super);

    function RoadTool(handle) {
      this.handle = handle != null ? handle : null;
      this.click = __bind(this.click, this);
      RoadTool.__super__.constructor.call(this);
      this.endNode = null;
    }

    RoadTool.prototype.click = function(e) {
      var nextHandle;

      if (this.curve != null) {
        if ((this.intersection != null) && (this.endNode == null)) {
          this.endNode = ents.splitRoad(this.intersection);
        }
        layers.main.drawBeizer(this.curve);
        nextHandle = ents.makeRoad(this.handle, this.curve, this.endNode);
        return tools.current = new RoadTool(nextHandle);
      }
    };

    RoadTool.prototype.over = function(ent, e) {
      var curve;

      if (ent instanceof ents.Node) {
        if (ent === this.handle.node) {
          return;
        }
        curve = C.fromHandle(this.handle, ent.pos);
        this.settle(curve);
        return this.draw();
      }
    };

    RoadTool.prototype.out = function(ent, e) {
      if (ent instanceof ents.Node) {
        return this.endNode = null;
      }
    };

    RoadTool.prototype.move = function(e) {
      var curve;

      if (this.endNode != null) {
        if (L(this.endNode.pos, P(e)).length() > 10) {
          this.endNode = null;
        } else {
          return;
        }
      }
      if (P(e).distance(this.handle.node.pos) <= 0) {
        return;
      }
      curve = C.fromHandle(this.handle, P(e));
      this.settle(curve);
      return this.draw();
    };

    RoadTool.prototype.settle = function(curve) {
      var intersectingNodeLength, intersectingRoadLength, iteration, unsettled;

      this.check(curve);
      this.intersection = null;
      this.endNode = null;
      if (this.curve != null) {
        iteration = 0;
        unsettled = true;
        while (unsettled) {
          curve = this.curve;
          curve = this.intersecting(curve);
          if (curve != null) {
            this.check(curve, true);
          }
          intersectingRoadLength = curveLen(this.curve);
          curve = this.intersectingNode(curve);
          if (curve != null) {
            this.check(curve, true);
          }
          intersectingNodeLength = curveLen(this.curve);
          if (intersectingNodeLength === intersectingRoadLength) {
            unsettled = false;
          }
          iteration++;
          if (iteration > 16) {
            console.warn("Can't settle, let's agree to disagree");
            this.curve = null;
            unsettled = false;
          }
        }
      }
      if (this.endNode === this.handle.node) {
        this.curve = null;
      }
      if ((this.curve != null) && curveLen(this.curve) < 10) {
        return this.curve = null;
      }
    };

    RoadTool.prototype.intersectingNode = function(curve) {
      var distFromCurveStart, distPntToNode, node, point, selected, shortest, _i, _len, _ref;

      this.endNode = null;
      selected = null;
      _ref = ents.nodes;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        node = _ref[_i];
        if (node === this.handle.node) {
          continue;
        }
        point = this.curve.getNearestPoint(node.pos);
        distPntToNode = L(point, node.pos).length();
        if (distPntToNode < 10) {
          distFromCurveStart = L(this.handle.node.pos, point).length();
          if (distFromCurveStart < shortest || (typeof shortest === "undefined" || shortest === null)) {
            selected = node;
            shortest = distFromCurveStart;
          }
        }
      }
      if (selected != null) {
        this.endNode = selected;
        return C.fromHandle(this.handle, selected.pos);
      } else {
        return null;
      }
    };

    RoadTool.prototype.intersecting = function(curve) {
      var cross, dist, inter, intersections, pos, road, selected, shortest, _i, _j, _k, _len, _len1, _len2, _ref, _ref1;

      this.intersection = null;
      intersections = [];
      _ref = ents.roads;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        road = _ref[_i];
        if (road.curve != null) {
          _ref1 = curve.getIntersections(road.curve);
          for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
            inter = _ref1[_j];
            inter.road = road;
            intersections.push(inter);
          }
        }
      }
      selected = null;
      for (_k = 0, _len2 = intersections.length; _k < _len2; _k++) {
        cross = intersections[_k];
        if ((cross != null ? cross._point : void 0) != null) {
          cross.p = P(cross._point.x, cross._point.y);
          dist = P(cross._point.x, cross._point.y).distance(this.handle.node.pos);
          if (dist < 1) {
            continue;
          }
          if (dist < shortest || (typeof shortest === "undefined" || shortest === null)) {
            shortest = dist;
            selected = cross;
          }
        }
      }
      if (selected != null) {
        pos = P(selected.p.x, selected.p.y);
        this.intersection = selected;
        return C.fromHandle(this.handle, pos);
      } else {
        return null;
      }
    };

    RoadTool.prototype.color = function() {
      var hue, k, v;

      hue = 0;
      for (k in colorSpeed) {
        v = colorSpeed[k];
        if (this.rad > new Number(k)) {
          hue = Math.max(v, hue);
        }
      }
      return "hsb(" + hue + ", 0.9, 0.5)";
    };

    RoadTool.prototype.check = function(curve, skipBackward) {
      var angle, isBackward, len;

      if (skipBackward == null) {
        skipBackward = false;
      }
      isBackward = L(curve.p1, curve.p2).length() > L(curve.p0, curve.p3).length();
      angle = Math.abs(L(curve.p0, curve.p1).signedAngle(L(curve.p2, curve.p3)));
      if (angle > Math.PI / 2 || (skipBackward && isBackward)) {
        this.curve = L(this.handle.node.pos, curve.p3).toCurve();
        this.rad = 99999;
        this.continous = false;
        return;
      }
      if (isBackward) {
        new RoadTool(this.handle.inverse);
      }
      len = curveLen(curve);
      this.rad = (len * ((2 * Math.PI) / angle)) / (2 * Math.PI);
      if (this.rad > 15) {
        this.curve = curve;
        return this.continous = true;
      }
    };

    RoadTool.prototype.draw = function() {
      var edge, _i, _len, _ref, _results;

      if (this.curve != null) {
        layers.tool.clear();
        layers.tool.drawBeizer(this.curve, this.color());
        _ref = this.handle.inverse.edges;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          edge = _ref[_i];
          _results.push(layers.tool.drawRoad(edge.road, "rgba(255,30,30,0.5)"));
        }
        return _results;
      }
    };

    RoadTool.prototype.keyDown = function(e) {
      if (e.which === 17) {
        return tools.current = new StraightRoadTool(this.node);
      }
    };

    return RoadTool;

  })(Tool);

  SharpTurnTool = (function(_super) {
    __extends(SharpTurnTool, _super);

    function SharpTurnTool(handle) {
      this.handle = handle;
      SharpTurnTool.__super__.constructor.call(this);
    }

    SharpTurnTool.prototype.click = function(e) {
      var nextHandle;

      if (this.line != null) {
        nextHandle = ents.makeRoad(this.handle, this.line.toCurve(), this.endNode);
        return new RoadTool(nextHandle);
      }
    };

    SharpTurnTool.prototype.move = function(e) {
      var curve;

      if (this.endNode == null) {
        curve = C.fromHandle(this.handle, P(e));
        this.line = L(this.handle.node.pos, P(e));
        this.check(curve);
        return this.draw();
      }
    };

    SharpTurnTool.prototype.over = function(ent, e) {
      var curve;

      if (ent instanceof ents.Node) {
        if (ent === this.handle.node) {
          return;
        }
        curve = C.fromHandle(this.handle, ent.pos);
        this.line = L(this.handle.node.pos, ent.pos);
        this.check(curve);
        this.endNode = ent;
        return this.draw();
      }
    };

    SharpTurnTool.prototype.out = function(ent, e) {
      if (ent instanceof ents.Node) {
        return this.endNode = null;
      }
    };

    SharpTurnTool.prototype.check = function(curve) {
      var angle;

      angle = Math.abs(L(curve.p0, curve.p1).signedAngle(L(curve.p2, curve.p3)));
      if (angle <= Math.PI / 2) {
        if (!(L(curve.p1, curve.p2).length() > L(curve.p0, curve.p3).length())) {
          return new RoadTool(this.handle);
        }
      }
    };

    SharpTurnTool.prototype.draw = function() {
      layers.tool.clear();
      return layers.tool.drawStraightRoad(this.line);
    };

    return SharpTurnTool;

  })(Tool);

  StraightRoadTool = (function(_super) {
    __extends(StraightRoadTool, _super);

    function StraightRoadTool(node) {
      this.node = node != null ? node : null;
      StraightRoadTool.__super__.constructor.call(this);
    }

    StraightRoadTool.prototype.click = function(e) {
      var line, node;

      line = this.straightLineFromNode(this.node, P(e));
      layers.main.drawLine(line);
      node = new ents.Node(line.p1, line.p0);
      return tools.current = new RoadTool(node);
    };

    StraightRoadTool.prototype.move = function(e) {
      var line;

      layers.tool.clear();
      line = this.straightLineFromNode(this.node, P(e));
      return layers.tool.drawLine(line);
    };

    StraightRoadTool.prototype.straightLineFromNode = function(node, pos) {
      var line, loc;

      line = L(node.pos, node.ctrl).growAdd(1000);
      loc = jsBezier.nearestPointOnCurve(pos, this.lineToBez(line)).location;
      return L(node.pos, node.ctrl).growAdd(1000 * loc);
    };

    StraightRoadTool.prototype.lineToBez = function(l) {
      return [
        {
          x: l.p0.x,
          y: l.p0.y
        }, {
          x: l.p0.x,
          y: l.p0.y
        }, {
          x: l.p1.x,
          y: l.p1.y
        }, {
          x: l.p1.x,
          y: l.p1.y
        }
      ];
    };

    StraightRoadTool.prototype.keyUp = function(e) {
      if (e.which === 17) {
        return tools.current = new RoadTool(this.node);
      }
    };

    return StraightRoadTool;

  })(Tool);

  root.tools = {};

  root.tools.RoadTool = RoadTool;

  root.tools.CommonTool = CommonTool;

}).call(this);
