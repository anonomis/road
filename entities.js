// Generated by CoffeeScript 1.6.2
(function() {
  var Edge, Handle, Node, Road, makeRoad, root, splitRoad;

  root = this;

  Node = (function() {
    function Node(pos, target) {
      this.pos = pos;
      if (target == null) {
        target = null;
      }
      this.handels = [];
      if (target != null) {
        new Handle(this, target);
      }
      layers.node.drawNode(this);
      layers.nodeSnap.addNodeSnapper(this);
    }

    Node.prototype.addHandle = function(handle) {
      if (this.handels.indexOf(handle === -1)) {
        this.handels.push(handle);
        this.handels.push(handle.inverse);
      }
      return handle;
    };

    Node.prototype.over = function(e) {
      var _base;

      if (typeof (_base = tools.current).over === "function") {
        _base.over(this, e);
      }
      return console.log("in", this);
    };

    Node.prototype.out = function(e) {
      var _base;

      if (typeof (_base = tools.current).out === "function") {
        _base.out(this, e);
      }
      layers.tool.clear();
      return console.log("out", this);
    };

    return Node;

  })();

  Handle = (function() {
    function Handle(node, pos, inverse) {
      this.node = node;
      this.pos = pos;
      this.inverse = inverse != null ? inverse : null;
      this.line = L(this.node.pos, this.pos);
      console.log(this.node, this.pos);
      this.edges = [];
      if (this.inverse == null) {
        this.inverse = new Handle(this.node, this.line.grow(-1).p1, this);
      }
      this.draw();
      this.node.addHandle(this);
    }

    Handle.prototype.draw = function() {
      return layers.main.drawHandle(this);
    };

    Handle.prototype.addEdge = function(edge) {
      return this.edges.push(edge);
    };

    Handle.prototype.removeEdge = function(edge) {
      return this.edges = _.without(edge);
    };

    return Handle;

  })();

  Edge = (function() {
    function Edge(from, to) {
      this.from = from;
      this.to = to;
      this.line = L(this.from.node.pos, this.to.node.pos);
      this.from.addEdge(this);
      this.to.addEdge(this);
    }

    Edge.prototype.addRoad = function(road) {
      return this.road = road;
    };

    Edge.prototype.destroy = function() {
      return this.road.destroy();
    };

    return Edge;

  })();

  Road = (function() {
    var defaults;

    defaults = {
      color: "#777"
    };

    function Road(edge, shape, opt) {
      this.edge = edge;
      this.shape = shape;
      this.opt = opt;
      this.opt = _.defaults(this.opt, defaults);
      this.edge.addRoad(this);
      this.draw();
      ents.roads.push(this);
    }

    Road.prototype.draw = function() {
      return this.elem = layers.main["drawRoad" + this.shape](this);
    };

    Road.prototype.destroy = function() {
      this.elem.remove();
      this.elem.parent.removeChild(this.elem);
      return ents.roads = _.without(ents.roads, this);
    };

    return Road;

  })();

  makeRoad = function(oldHandle, end, target, curve, newNode) {
    var edge, newHandle, shape;

    if (curve == null) {
      curve = null;
    }
    if (newNode == null) {
      newNode = null;
    }
    if (newNode == null) {
      newNode = new Node(end);
    }
    newHandle = new Handle(newNode, target);
    edge = new Edge(oldHandle, newHandle);
    if (curve != null) {
      shape = "Curve";
    } else {
      shape = "Line";
    }
    new Road(edge, shape, {
      curve: curve
    });
    return newHandle.inverse;
  };

  splitRoad = function(intersection) {
    var curve, curveToSplit, curves, edge1, edge2, edgeToSplit, handleIn, handleOut, intersectionPoint, newNode, param;

    edgeToSplit = intersection.road.edge;
    curveToSplit = intersection.road.opt.curve;
    intersectionPoint = intersection._point;
    console.log("intersectionpoint", intersectionPoint);
    param = curveToSplit.getParameterOf(intersectionPoint);
    console.log("param", param);
    curves = split(curveToSplit, param);
    console.log("curves", curves);
    newNode = new Node(curves.left.p3);
    handleIn = new Handle(newNode, curves.left.p2, "later");
    handleOut = new Handle(newNode, curves.right.p1, "later");
    handleIn.inverse = handleOut;
    handleOut.inverse = handleIn;
    edge1 = new Edge(edgeToSplit.from, handleIn);
    curve = C({
      p0: edgeToSplit.from.node.pos,
      p1: curves.left.p1,
      p2: handleIn.pos,
      p3: newNode.pos
    });
    new Road(edge1, edgeToSplit.road.shape, {
      curve: curve
    });
    edge2 = new Edge(handleOut, edgeToSplit.to);
    curve = C({
      p0: newNode.pos,
      p1: handleOut.pos,
      p2: curves.right.p3,
      p3: edgeToSplit.to.node.pos
    });
    new Road(edge2, edgeToSplit.road.shape, {
      curve: curve
    });
    edgeToSplit.to.removeEdge(edgeToSplit);
    edgeToSplit.from.removeEdge(edgeToSplit);
    edgeToSplit.destroy();
    return newNode;
  };

  root.ents = {};

  root.ents.makeRoad = makeRoad;

  root.ents.splitRoad = splitRoad;

  root.ents.Node = Node;

  root.ents.Handle = Handle;

  root.ents.roads = [];

}).call(this);
