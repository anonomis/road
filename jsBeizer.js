// Generated by CoffeeScript 1.6.2
(function() {
  var Vectors, flatnessTolerance, jsBezier, maxRecursion, _bezier, _computeXIntercept, _convertToBezier, _curveFunctionCache, _dist, _distanceFromCurve, _findRoots, _getCrossingCount, _getCurveFunctions, _gradientAtPoint, _gradientAtPointAlongPathFrom, _isFlatEnough, _isPoint, _length, _locationAlongPathFrom, _nearestPointOnCurve, _perpendicularToPathAt, _pointAlongPath, _pointAlongPathFrom, _pointOnPath;

  if (typeof Math.sgn === "undefined") {
    Math.sgn = function(x) {
      if (x === 0) {
        return 0;
      } else {
        if (x > 0) {
          return 1;
        } else {
          return -1;
        }
      }
    };
  }

  Vectors = {
    subtract: function(v1, v2) {
      return {
        x: v1.x - v2.x,
        y: v1.y - v2.y
      };
    },
    dotProduct: function(v1, v2) {
      return (v1.x * v2.x) + (v1.y * v2.y);
    },
    square: function(v) {
      return Math.sqrt((v.x * v.x) + (v.y * v.y));
    },
    scale: function(v, s) {
      return {
        x: v.x * s,
        y: v.y * s
      };
    }
  };

  maxRecursion = 64;

  flatnessTolerance = Math.pow(2.0, -maxRecursion - 1);

  /*
  Calculates the distance that the point lies from the curve.
  
  @param point a point in the form {x:567, y:3342}
  @param curve a Bezier curve in the form [{x:..., y:...}, {x:..., y:...}, {x:..., y:...}, {x:..., y:...}].  note that this is currently
  hardcoded to assume cubiz beziers, but would be better off supporting any degree.
  @return a JS object literal containing location and distance, for example: {location:0.35, distance:10}.  Location is analogous to the location
  argument you pass to the pointOnPath function: it is a ratio of distance travelled along the curve.  Distance is the distance in pixels from
  the point to the curve.
  */


  _distanceFromCurve = function(point, curve) {
    var candidates, degree, dist, higherDegree, i, newDist, numSolutions, t, v, w;

    candidates = [];
    w = _convertToBezier(point, curve);
    degree = curve.length - 1;
    higherDegree = (2 * degree) - 1;
    numSolutions = _findRoots(w, higherDegree, candidates, 0);
    v = Vectors.subtract(point, curve[0]);
    dist = Vectors.square(v);
    t = 0.0;
    i = 0;
    while (i < numSolutions) {
      v = Vectors.subtract(point, _bezier(curve, degree, candidates[i], null, null));
      newDist = Vectors.square(v);
      if (newDist < dist) {
        dist = newDist;
        t = candidates[i];
      }
      i++;
    }
    v = Vectors.subtract(point, curve[degree]);
    newDist = Vectors.square(v);
    if (newDist < dist) {
      dist = newDist;
      t = 1.0;
    }
    return {
      location: t,
      distance: dist
    };
  };

  /*
  finds the nearest point on the curve to the given point.
  */


  _nearestPointOnCurve = function(point, curve) {
    var td;

    td = _distanceFromCurve(point, curve);
    return {
      point: _bezier(curve, curve.length - 1, td.location, null, null),
      location: td.location
    };
  };

  _convertToBezier = function(point, curve) {
    var c, cdTable, column, d, degree, higherDegree, i, j, k, lb, m, n, row, ub, w, z;

    degree = curve.length - 1;
    higherDegree = (2 * degree) - 1;
    c = [];
    d = [];
    cdTable = [];
    w = [];
    z = [[1.0, 0.6, 0.3, 0.1], [0.4, 0.6, 0.6, 0.4], [0.1, 0.3, 0.6, 1.0]];
    i = 0;
    while (i <= degree) {
      c[i] = Vectors.subtract(curve[i], point);
      i++;
    }
    i = 0;
    while (i <= degree - 1) {
      d[i] = Vectors.subtract(curve[i + 1], curve[i]);
      d[i] = Vectors.scale(d[i], 3.0);
      i++;
    }
    row = 0;
    while (row <= degree - 1) {
      column = 0;
      while (column <= degree) {
        if (!cdTable[row]) {
          cdTable[row] = [];
        }
        cdTable[row][column] = Vectors.dotProduct(d[row], c[column]);
        column++;
      }
      row++;
    }
    i = 0;
    while (i <= higherDegree) {
      if (!w[i]) {
        w[i] = [];
      }
      w[i].y = 0.0;
      w[i].x = parseFloat(i) / higherDegree;
      i++;
    }
    n = degree;
    m = degree - 1;
    k = 0;
    while (k <= n + m) {
      lb = Math.max(0, k - m);
      ub = Math.min(k, n);
      i = lb;
      while (i <= ub) {
        j = k - i;
        w[i + j].y += cdTable[j][i] * z[j][i];
        i++;
      }
      k++;
    }
    return w;
  };

  /*
  counts how many roots there are.
  */


  _findRoots = function(w, degree, t, depth) {
    var i, left, left_count, left_t, right, right_count, right_t;

    left = [];
    right = [];
    left_count = void 0;
    right_count = void 0;
    left_t = [];
    right_t = [];
    switch (_getCrossingCount(w, degree)) {
      case 0:
        return 0;
      case 1:
        if (depth >= maxRecursion) {
          t[0] = (w[0].x + w[degree].x) / 2.0;
          return 1;
        }
        if (_isFlatEnough(w, degree)) {
          t[0] = _computeXIntercept(w, degree);
          return 1;
        }
        break;
    }
    _bezier(w, degree, 0.5, left, right);
    left_count = _findRoots(left, degree, left_t, depth + 1);
    right_count = _findRoots(right, degree, right_t, depth + 1);
    i = 0;
    while (i < left_count) {
      t[i] = left_t[i];
      i++;
    }
    i = 0;
    while (i < right_count) {
      t[i + left_count] = right_t[i];
      i++;
    }
    return left_count + right_count;
  };

  _getCrossingCount = function(curve, degree) {
    var i, n_crossings, old_sign, sign;

    n_crossings = 0;
    sign = void 0;
    old_sign = void 0;
    sign = old_sign = Math.sgn(curve[0].y);
    i = 1;
    while (i <= degree) {
      sign = Math.sgn(curve[i].y);
      if (sign !== old_sign) {
        n_crossings++;
      }
      old_sign = sign;
      i++;
    }
    return n_crossings;
  };

  _isFlatEnough = function(curve, degree) {
    var a, a1, a2, b, b1, b2, c, c1, c2, dInv, det, error, i, intercept_1, intercept_2, left_intercept, max_distance_above, max_distance_below, right_intercept, value;

    error = void 0;
    intercept_1 = void 0;
    intercept_2 = void 0;
    left_intercept = void 0;
    right_intercept = void 0;
    a = void 0;
    b = void 0;
    c = void 0;
    det = void 0;
    dInv = void 0;
    a1 = void 0;
    b1 = void 0;
    c1 = void 0;
    a2 = void 0;
    b2 = void 0;
    c2 = void 0;
    a = curve[0].y - curve[degree].y;
    b = curve[degree].x - curve[0].x;
    c = curve[0].x * curve[degree].y - curve[degree].x * curve[0].y;
    max_distance_above = max_distance_below = 0.0;
    i = 1;
    while (i < degree) {
      value = a * curve[i].x + b * curve[i].y + c;
      if (value > max_distance_above) {
        max_distance_above = value;
      } else {
        if (value < max_distance_below) {
          max_distance_below = value;
        }
      }
      i++;
    }
    a1 = 0.0;
    b1 = 1.0;
    c1 = 0.0;
    a2 = a;
    b2 = b;
    c2 = c - max_distance_above;
    det = a1 * b2 - a2 * b1;
    dInv = 1.0 / det;
    intercept_1 = (b1 * c2 - b2 * c1) * dInv;
    a2 = a;
    b2 = b;
    c2 = c - max_distance_below;
    det = a1 * b2 - a2 * b1;
    dInv = 1.0 / det;
    intercept_2 = (b1 * c2 - b2 * c1) * dInv;
    left_intercept = Math.min(intercept_1, intercept_2);
    right_intercept = Math.max(intercept_1, intercept_2);
    error = right_intercept - left_intercept;
    if (error < flatnessTolerance) {
      return 1;
    } else {
      return 0;
    }
  };

  _computeXIntercept = function(curve, degree) {
    var S, XLK, XMK, XNM, YLK, YMK, YNM, det, detInv;

    XLK = 1.0;
    YLK = 0.0;
    XNM = curve[degree].x - curve[0].x;
    YNM = curve[degree].y - curve[0].y;
    XMK = curve[0].x - 0.0;
    YMK = curve[0].y - 0.0;
    det = XNM * YLK - YNM * XLK;
    detInv = 1.0 / det;
    S = (XNM * YMK - YNM * XMK) * detInv;
    return 0.0 + XLK * S;
  };

  _bezier = function(curve, degree, t, left, right) {
    var i, j, temp;

    temp = [[]];
    j = 0;
    while (j <= degree) {
      temp[0][j] = curve[j];
      j++;
    }
    i = 1;
    while (i <= degree) {
      j = 0;
      while (j <= degree - i) {
        if (!temp[i]) {
          temp[i] = [];
        }
        if (!temp[i][j]) {
          temp[i][j] = {};
        }
        temp[i][j].x = (1.0 - t) * temp[i - 1][j].x + t * temp[i - 1][j + 1].x;
        temp[i][j].y = (1.0 - t) * temp[i - 1][j].y + t * temp[i - 1][j + 1].y;
        j++;
      }
      i++;
    }
    if (left != null) {
      j = 0;
      while (j <= degree) {
        left[j] = temp[j][0];
        j++;
      }
    }
    if (right != null) {
      j = 0;
      while (j <= degree) {
        right[j] = temp[degree - j][j];
        j++;
      }
    }
    return temp[degree][0];
  };

  _curveFunctionCache = {};

  _getCurveFunctions = function(order) {
    var c_term, f_term, fns, i, j, l_term, one_minus_t_term, t_term, terms, _termFunc;

    fns = _curveFunctionCache[order];
    if (!fns) {
      fns = [];
      f_term = function() {
        return function(t) {
          return Math.pow(t, order);
        };
      };
      l_term = function() {
        return function(t) {
          return Math.pow(1 - t, order);
        };
      };
      c_term = function(c) {
        return function(t) {
          return c;
        };
      };
      t_term = function() {
        return function(t) {
          return t;
        };
      };
      one_minus_t_term = function() {
        return function(t) {
          return 1 - t;
        };
      };
      _termFunc = function(terms) {
        return function(t) {
          var i, p;

          p = 1;
          i = 0;
          while (i < terms.length) {
            p = p * terms[i](t);
            i++;
          }
          return p;
        };
      };
      fns.push(new f_term());
      i = 1;
      while (i < order) {
        terms = [new c_term(order)];
        j = 0;
        while (j < (order - i)) {
          terms.push(new t_term());
          j++;
        }
        j = 0;
        while (j < i) {
          terms.push(new one_minus_t_term());
          j++;
        }
        fns.push(new _termFunc(terms));
        i++;
      }
      fns.push(new l_term());
      _curveFunctionCache[order] = fns;
    }
    return fns;
  };

  /*
  calculates a point on the curve, for a Bezier of arbitrary order.
  @param curve an array of control points, eg [{x:10,y:20}, {x:50,y:50}, {x:100,y:100}, {x:120,y:100}].  For a cubic bezier this should have four points.
  @param location a decimal indicating the distance along the curve the point should be located at.  this is the distance along the curve as it travels, taking the way it bends into account.  should be a number from 0 to 1, inclusive.
  */


  _pointOnPath = function(curve, location) {
    var cc, i, _x, _y;

    cc = _getCurveFunctions(curve.length - 1);
    _x = 0;
    _y = 0;
    i = 0;
    while (i < curve.length) {
      _x = _x + (curve[i].x * cc[i](location));
      _y = _y + (curve[i].y * cc[i](location));
      i++;
    }
    return {
      x: _x,
      y: _y
    };
  };

  _dist = function(p1, p2) {
    return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));
  };

  _isPoint = function(curve) {
    return curve[0].x === curve[1].x && curve[0].y === curve[1].y;
  };

  /*
  finds the point that is 'distance' along the path from 'location'.  this method returns both the x,y location of the point and also
  its 'location' (proportion of travel along the path); the method below - _pointAlongPathFrom - calls this method and just returns the
  point.
  */


  _pointAlongPath = function(curve, location, distance) {
    var cur, curLoc, direction, prev, tally;

    if (_isPoint(curve)) {
      return {
        point: curve[0],
        location: location
      };
    }
    prev = _pointOnPath(curve, location);
    tally = 0;
    curLoc = location;
    direction = (distance > 0 ? 1 : -1);
    cur = null;
    while (tally < Math.abs(distance)) {
      curLoc += 0.005 * direction;
      cur = _pointOnPath(curve, curLoc);
      tally += _dist(cur, prev);
      prev = cur;
    }
    return {
      point: cur,
      location: curLoc
    };
  };

  _length = function(curve) {
    var cur, curLoc, direction, prev, tally;

    if (_isPoint(curve)) {
      return 0;
    }
    prev = _pointOnPath(curve, 0);
    tally = 0;
    curLoc = 0;
    direction = 1;
    cur = null;
    while (curLoc < 1) {
      curLoc += 0.005 * direction;
      cur = _pointOnPath(curve, curLoc);
      tally += _dist(cur, prev);
      prev = cur;
    }
    return tally;
  };

  /*
  finds the point that is 'distance' along the path from 'location'.
  */


  _pointAlongPathFrom = function(curve, location, distance) {
    return _pointAlongPath(curve, location, distance).point;
  };

  /*
  finds the location that is 'distance' along the path from 'location'.
  */


  _locationAlongPathFrom = function(curve, location, distance) {
    return _pointAlongPath(curve, location, distance).location;
  };

  /*
  returns the gradient of the curve at the given location, which is a decimal between 0 and 1 inclusive.
  
  thanks // http://bimixual.org/AnimationLibrary/beziertangents.html
  */


  _gradientAtPoint = function(curve, location) {
    var dx, dy, p1, p2;

    p1 = _pointOnPath(curve, location);
    p2 = _pointOnPath(curve.slice(0, curve.length - 1), location);
    dy = p2.y - p1.y;
    dx = p2.x - p1.x;
    if (dy === 0) {
      return Infinity;
    } else {
      return Math.atan(dy / dx);
    }
  };

  /*
  returns the gradient of the curve at the point which is 'distance' from the given location.
  if this point is greater than location 1, the gradient at location 1 is returned.
  if this point is less than location 0, the gradient at location 0 is returned.
  */


  _gradientAtPointAlongPathFrom = function(curve, location, distance) {
    var p;

    p = _pointAlongPath(curve, location, distance);
    if (p.location > 1) {
      p.location = 1;
    }
    if (p.location < 0) {
      p.location = 0;
    }
    return _gradientAtPoint(curve, p.location);
  };

  /*
  calculates a line that is 'length' pixels long, perpendicular to, and centered on, the path at 'distance' pixels from the given location.
  if distance is not supplied, the perpendicular for the given location is computed (ie. we set distance to zero).
  */


  _perpendicularToPathAt = function(curve, location, length, distance) {
    var m, p, x, y, _theta2;

    distance = (distance == null ? 0 : distance);
    p = _pointAlongPath(curve, location, distance);
    m = _gradientAtPoint(curve, p.location);
    _theta2 = Math.atan(-1 / m);
    y = length / 2 * Math.sin(_theta2);
    x = length / 2 * Math.cos(_theta2);
    return [
      {
        x: p.point.x + x,
        y: p.point.y + y
      }, {
        x: p.point.x - x,
        y: p.point.y - y
      }
    ];
  };

  jsBezier = window.jsBezier = {
    distanceFromCurve: _distanceFromCurve,
    gradientAtPoint: _gradientAtPoint,
    gradientAtPointAlongCurveFrom: _gradientAtPointAlongPathFrom,
    nearestPointOnCurve: _nearestPointOnCurve,
    pointOnCurve: _pointOnPath,
    pointAlongCurveFrom: _pointAlongPathFrom,
    perpendicularToCurveAt: _perpendicularToPathAt,
    locationAlongCurveFrom: _locationAlongPathFrom,
    getLength: _length
  };

}).call(this);

/*
//@ sourceMappingURL=jsBeizer.map
*/
